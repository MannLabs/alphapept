---

title: Score


keywords: fastai
sidebar: home_sidebar

summary: "Functions related to the score"
description: "Functions related to the score"
nb_path: "nbs\06_score.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs\06_score.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This notebook contains all functions related to the scoring of peptide-spectrum-matches (PSMS).</p>
<p>In brief, this notebook includes the following:</p>
<ul>
<li>Functions for target-decoy based FDR estimation</li>
<li>X!tandem based scoring of PSMs</li>
<li>Machine learning based scoring of PSMs</li>
<li>Protein grouping by the razor approach</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Filtering">Filtering<a class="anchor-link" href="#Filtering"> </a></h2><p>The filtering functions are essential base functions for scoring in AlphaPept. They make sure that only the 'best precursor per spectum' and the 'best spectrum per precursor' is used.</p>
<p>Recall from the search that when having feautres, <code>raw_idx</code> refers to the actual index from the raw data. Otherwise it is<code>query_data</code>.</p>
<p>For filtering, we have several functions. When applying for a score, we first use <a href="/alphapept/score.html#filter_score"><code>filter_score</code></a> and then <a href="/alphapept/score.html#filter_precursor"><code>filter_precursor</code></a>.
<a href="/alphapept/score.html#filter_score"><code>filter_score</code></a> is keeping the best score per experimental spectrum. First we rank by score for each <code>query_idx</code>. As we have multiple hits for each experimental spectrum from the search we only want to keep the best one.</p>
<p>When performing feature finding, we assign multiple possible features to each experimental spectrum. The idea here is that a spectrum could originate from various precursors. To disentangle these psms we can use the following modes:</p>
<ul>
<li><code>single</code>: This mode will only keep one feature per experimental spectrum (the one with the highest score and the closest distance). Each feature can only occur once.</li>
<li><code>multiple</code>: Allow multiple features per experimental spectrum. Each feature can only occur once.</li>
</ul>
<p><code>filter_precusor</code> is intended for the case that a precursor (charge + sequence) occurs more than once. Only the one with the highest score will be kept.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="filter_score" class="doc_header"><code>filter_score</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L14" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>filter_score</code>(<strong><code>df</code></strong>, <strong><code>mode</code></strong>=<em><code>'multiple'</code></em>)</p>
</blockquote>
<p>Filter df by score
TODO: PSMS could still have the same score when having modifications at multiple positions that are not distinguishable.
Only keep one.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="filter_precursor" class="doc_header"><code>filter_precursor</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L47" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>filter_precursor</code>(<strong><code>df</code></strong>)</p>
</blockquote>
<p>Filter df by precursor
Allow each precursor only once.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Q-Values">Q-Values<a class="anchor-link" href="#Q-Values"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/alphapept/score.html#get_q_values"><code>get_q_values</code></a> is used to calculate q-values from FDR values. The direct relationship is illustrated further down in the notebook.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_q_values" class="doc_header"><code>get_q_values</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L62" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_q_values</code>(<strong><code>fdr_values</code></strong>)</p>
</blockquote>
<p>Calculate q values from fdr_values</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="FDR">FDR<a class="anchor-link" href="#FDR"> </a></h2><p>The employed FDR strategy is based on a classical target-decoy competition approach. The procedure works as follows:</p>
<ol>
<li>Consider only the best scoring target or decoy PSM per spectrum. </li>
<li>Sort all PSMs by decreasing scores.</li>
<li>Estimate the FDR as #decoys / #targets, where #targets (#decoys) is the number of positive target (decoy) PSMs at a given score threshold t (i.e. PSMs with scores higher than t).</li>
<li>Convert the estimated FDR to q-values by selecting the minimum FDR at which the identification could be made, i.e. the lowest score threshold t that could be set to include an identification without increasing the number of false positives.</li>
<li>Report the set of target PSMs with q-values smaller or equal to the selected <code>fdr_level</code>.</li>
</ol>
<p>Informative literature describing and discussing different FDR estimation approaches for shotgun proteomics can be found here (the implemented strategy in alphapept is referred to as T-TDC in this article):</p>
<blockquote><p>Keich, Uri et al. "Improved False Discovery Rate Estimation Procedure for Shotgun Proteomics." Journal of proteome research vol. 14,8 (2015):3148-61. <a href="https://pubs.acs.org/doi/10.1021/acs.jproteome.5b00081">https://pubs.acs.org/doi/10.1021/acs.jproteome.5b00081</a></p>
</blockquote>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="cut_fdr" class="doc_header"><code>cut_fdr</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L83" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>cut_fdr</code>(<strong><code>df</code></strong>, <strong><code>fdr_level</code></strong>=<em><code>0.01</code></em>, <strong><code>plot</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Cuts a dataframe with a given fdr level</p>
<p>Args:
    fdr_level: fdr level that should be used
    plot: flag to enable plot</p>
<p>Returns:
    cutoff: df with psms within fdr
    cutoff_value: numerical value of score cutoff</p>
<p>Raises:</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Simulation of random scores for 50'000 measurements (corresponding to spectra). Simulated are decoys, true targets and false targets. We assume a false traget raio (pi0) of 0.8 and a mean score difference of 3.5.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Simulated score distribution for a separate target and decoy database search:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Simulated score distribution for a corresponding concatinated target-decoy database search with target-decoy-competition:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Application of the <a href="/alphapept/score.html#cut_fdr"><code>cut_fdr</code></a> function to the simulated target-decoy competition dataset saved in <code>TDC</code>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">cval</span><span class="p">,</span> <span class="n">cut_TDC</span> <span class="o">=</span> <span class="n">cut_fdr</span><span class="p">(</span><span class="n">TDC</span><span class="p">,</span> <span class="n">fdr_level</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Evaluation of the FDR estimated by the target-decoy approach versus the true FDR confirms accurate FDR estimation by our approach. The true FDR is capped by the selected fraction of false targets (pi0 = 0.8) and by the effect of target decoy competition. Similarly, the true positive rate (TPR) is limited by the effect of target decoy competition and can only reach 1 in cases where not a single decoy scores higher than a true target.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The following figure illustrates the difference between <code>fdr</code> and <code>q_value</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Please be aware that the shown simulations are not an accurate model for PSMS scoring and they were designed only for illustrative purposes and to test the implemeted functions.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Global-FDR">Global FDR<a class="anchor-link" href="#Global-FDR"> </a></h2><p>The <a href="/alphapept/score.html#cut_global_fdr"><code>cut_global_fdr</code></a> function has two specific applications:</p>
<ol>
<li><strong>Estimate q-values on the peptide and protein level</strong> <br/>
The concept here is based on selecting the best scoring precursor per peptide (or protein) to then estimate the FDR by target-decoy competition using the <a href="/alphapept/score.html#cut_fdr"><code>cut_fdr</code></a> function.</li>
<li><strong>Estimate q-values across an entire dataset on either precursor, peptide or protein level</strong> <br/>
The concept here is based on selecting the best scoring precursor, peptide or protein signal across an entire dataset to then estimate the FDR by target-decoy competition using the <a href="/alphapept/score.html#cut_fdr"><code>cut_fdr</code></a> function.</li>
</ol>
<p>This strategy was extensively tested and discussed in the following publications:</p>
<blockquote><p>Nesvizhskii, Alexey I. "A survey of computational methods and error rate estimation procedures for peptide and protein identification in shotgun proteomics." Journal of proteomics vol. 73,11 (2010):2092-123. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2956504/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2956504/</a> &gt; Savitski, Mikhail M et al. "A Scalable Approach for Protein False Discovery Rate Estimation in Large Proteomic Data Sets." Molecular &amp; cellular proteomics :MCP vol. 14,9 (2015): 2394-404. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4563723/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4563723/</a>&gt; The, Matthew et al. "Fast and Accurate Protein False Discovery Rates on Large-Scale Proteomics Data Sets with Percolator 3.0." Journal of the American Society for Mass Spectrometry vol. 27,11 (2016):1719-1727. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5059416/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5059416/</a>&gt; Gupta, Nitin, and Pavel A Pevzner. "False discovery rates of protein identifications:a strike against the two-peptide rule." Journal of proteome research vol. 8,9 (2009): 4173-81. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3398614/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3398614/</a></p>
</blockquote>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="cut_global_fdr" class="doc_header"><code>cut_global_fdr</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L164" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>cut_global_fdr</code>(<strong><code>data</code></strong>, <strong><code>analyte_level</code></strong>=<em><code>'sequence'</code></em>, <strong><code>fdr_level</code></strong>=<em><code>0.01</code></em>, <strong><code>plot</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Function to estimate and filter by global peptide or protein fdr</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Similar to the sequence level simulations we can simulatae score distributions for peptides beloning to proteins. In our simulation we assumed a poisson distribution for the number of peptides for each protein centered at 4 peptides.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Application of the <a href="/alphapept/score.html#cut_global_fdr"><code>cut_global_fdr</code></a> function to the simulated protein-level target-decoy competition dataset saved in <code>TDC_prot</code>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">cut_TDC_prot</span> <span class="o">=</span> <span class="n">cut_global_fdr</span><span class="p">(</span><span class="n">TDC_prot</span><span class="p">,</span> <span class="n">fdr_level</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">analyte_level</span><span class="o">=</span><span class="s1">&#39;protein&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Evaluation of the protein-level FDR estimated by the target-decoy approach versus the true FDR confirms accurate FDR estimation by our approach:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Investigating the peptide-level statistics after protein-level FDR filtering shows a conservative pattern.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Please be aware that the shown simulations are not an accurate model for PSMS scoring and they were designed only for illustrative purposes and to test the implemeted functions.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Scoring">Scoring<a class="anchor-link" href="#Scoring"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="X!tandem-scoring">X!tandem scoring<a class="anchor-link" href="#X!tandem-scoring"> </a></h3><ul>
<li><p><a href="/alphapept/score.html#get_x_tandem_score"><code>get_x_tandem_score</code></a> performs scoring of PSMs according to the X!tandem strategy:</p>
</li>
<li><p><a href="/alphapept/score.html#score_x_tandem"><code>score_x_tandem</code></a> first calls <a href="/alphapept/score.html#get_x_tandem_score"><code>get_x_tandem_score</code></a> and and subsequently applies the <a href="/alphapept/score.html#cut_fdr"><code>cut_fdr</code></a> function to filter PSMs at the specified <code>fdr_level</code>.</p>
</li>
</ul>
<blockquote><p>X!Tandem, Craig,R. and Beavis,R.C. (2003) Rapid Commun. Mass Spectrom., 17, 2310-2316</p>
</blockquote>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_x_tandem_score" class="doc_header"><code>get_x_tandem_score</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L194" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_x_tandem_score</code>(<strong><code>df</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="score_x_tandem" class="doc_header"><code>score_x_tandem</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L204" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>score_x_tandem</code>(<strong><code>df</code></strong>, <strong><code>fdr_level</code></strong>=<em><code>0.01</code></em>, <strong><code>plot</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="filter_with_x_tandem" class="doc_header"><code>filter_with_x_tandem</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L215" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>filter_with_x_tandem</code>(<strong><code>df</code></strong>, <strong><code>fdr_level</code></strong>=<em><code>0.01</code></em>)</p>
</blockquote>
<p>Filters a dataframe using an x_tandem score</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Score-and-filter-PSMs-by-any-specified-score">Score and filter PSMs by any specified score<a class="anchor-link" href="#Score-and-filter-PSMs-by-any-specified-score"> </a></h3><p><a href="/alphapept/score.html#score_psms"><code>score_psms</code></a> uses the specified <a href="/alphapept/score.html"><code>score</code></a> and applies the <a href="/alphapept/score.html#cut_fdr"><code>cut_fdr</code></a> function to filter PSMs at the specified <code>fdr_level</code>. <a href="/alphapept/score.html#filter_score"><code>filter_score</code></a> and <a href="/alphapept/score.html#filter_precursor"><code>filter_precursor</code></a> are applied to only report the best PSM per acquired spectrum and the best signal per precursor (i.e. sequence + charge combination).</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="score_psms" class="doc_header"><code>score_psms</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L231" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>score_psms</code>(<strong><code>df</code></strong>, <strong><code>score</code></strong>=<em><code>'y_hits'</code></em>, <strong><code>fdr_level</code></strong>=<em><code>0.01</code></em>, <strong><code>plot</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Machine-learning-based-scoring-of-PSMs">Machine learning based scoring of PSMs<a class="anchor-link" href="#Machine-learning-based-scoring-of-PSMs"> </a></h2><ul>
<li><p><a href="/alphapept/score.html#get_ML_features"><code>get_ML_features</code></a> extracts additional scoring metrics for the machine learning, including the number of amino acids per precursor, the number of missed cleavages and the logarithmic number of times the same peptide occurs in the set of PSMs</p>
</li>
<li><p><a href="/alphapept/score.html#train_RF"><code>train_RF</code></a> trains a random forest classifier for scoring all PSMs. For this, we use the scikit-learn library.</p>
<ul>
<li>First, a machine learning pipeline is created including the sklearn <code>StandardScaler</code> and <code>RandomForestClassifier</code>. The <code>StandardScaler</code> is used to standardize all features by removing the mean and scaling to unit variance. For details on the <code>RandomForestClassifier</code> see: <a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html</a>.</li>
<li>Next, a grid search is initialized for testing the hyperparameter space (<code>max_depth</code> and <code>max_leaf_nodes</code>) of the random forest classifier by a 5-fold cross-validation using <code>GridSearchCV</code>.</li>
<li>To train the classifier, we first select a suitable set of PSMSs. This is achieved by an initial scoring and FDR estimation of the input PSMs based on the <code>ini_score</code>. Only targets below the <code>train_fdr_level</code> cutoff are considered for training the classifier. To ensure a balanced dataset for training (i.e. same number of targets and decoys), the number of PSMs per category is selected to be the minimum of either the number of high scoring targets below the <code>train_fdr_level</code> cutoff or the overall number of decoys among the PSMs. <code>min_train</code> specifies the minimum number of targets and decoys that should be available. </li>
<li>Once a balanced set of PSMs is established, the PSMs are split into a training and test set accoring to the <code>test_size</code> argument using <code>train_test_split</code> from sklearn while ensuring the PSMs are split in a stratified fashion (i.e. equal number of targets and decoys in both the training and test sets).</li>
<li>The grid search and training of the random forest classifier is performed on the training set of PSMs. The <code>GridSearchCV</code> returns the classifier which performed best across all cross-validation hold-out sets according to the <code>scoring</code> function (classification <em>'accuracy'</em> is set as default score). The grid search is parallelize dinto <code>n_jobs</code>.</li>
<li>Next, the trained classifier is applied to the testing set of PSMs and the test score is reported. </li>
<li>If <code>plot</code> is enabled, a figure illustrating the weights of each feature is produced.</li>
<li>Finally the function returns the trained random forest classifier for subsequent application to the entire set of PSMs or for transfering to a different dataset. </li>
</ul>
</li>
<li><p><a href="/alphapept/score.html#score_ML"><code>score_ML</code></a> applies a classifier trained by <a href="/alphapept/score.html#train_RF"><code>train_RF</code></a> to a complete set of PSMs. It calls the <a href="/alphapept/score.html#cut_fdr"><code>cut_fdr</code></a> function and filters for the specified <code>fdr_level</code>. <a href="/alphapept/score.html#filter_score"><code>filter_score</code></a> and <a href="/alphapept/score.html#filter_precursor"><code>filter_precursor</code></a> are applied to only report the best PSM per acquired spectrum and the best signal per precursor (i.e. sequence + charge combination).</p>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_ML_features" class="doc_header"><code>get_ML_features</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L261" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_ML_features</code>(<strong><code>df</code></strong>, <strong><code>protease</code></strong>=<em><code>'trypsin'</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="train_RF" class="doc_header"><code>train_RF</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L276" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>train_RF</code>(<strong><code>df</code></strong>, <strong><code>exclude_features</code></strong>=<em><code>['precursor_idx', 'ion_idx', 'fasta_index', 'feature_rank', 'raw_rank', 'rank', 'db_idx', 'feature_idx', 'precursor', 'query_idx', 'raw_idx', 'sequence', 'decoy', 'naked_sequence']</code></em>, <strong><code>train_fdr_level</code></strong>=<em><code>0.1</code></em>, <strong><code>ini_score</code></strong>=<em><code>'x_tandem'</code></em>, <strong><code>min_train</code></strong>=<em><code>5000</code></em>, <strong><code>test_size</code></strong>=<em><code>0.8</code></em>, <strong><code>max_depth</code></strong>=<em><code>[5, 25, 50]</code></em>, <strong><code>max_leaf_nodes</code></strong>=<em><code>[150, 200, 250]</code></em>, <strong><code>n_jobs</code></strong>=<em><code>1</code></em>, <strong><code>scoring</code></strong>=<em><code>'accuracy'</code></em>, <strong><code>plot</code></strong>=<em><code>False</code></em>, <strong><code>random_state</code></strong>=<em><code>42</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="score_ML" class="doc_header"><code>score_ML</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L364" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>score_ML</code>(<strong><code>df</code></strong>, <strong><code>trained_classifier</code></strong>, <strong><code>features</code></strong>=<em><code>None</code></em>, <strong><code>fdr_level</code></strong>=<em><code>0.01</code></em>, <strong><code>plot</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="filter_with_ML" class="doc_header"><code>filter_with_ML</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L382" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>filter_with_ML</code>(<strong><code>df</code></strong>, <strong><code>trained_classifier</code></strong>, <strong><code>features</code></strong>=<em><code>None</code></em>, <strong><code>fdr_level</code></strong>=<em><code>0.01</code></em>, <strong><code>plot</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Filters a dataframe using ML</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Protein-grouping">Protein grouping<a class="anchor-link" href="#Protein-grouping"> </a></h2><p>For protein grouping, we implement a razor approach. Here, we check whether a protein has unique PSMs, meaning that the peptide can only belong to one protein. For all ambiguous proteins, were PSMs could be shared between multiple proteins, we employ the razor-approach, which is implemented with the networkx-package.</p>
<p>We create a network and add all connections between the peptides and proteins. Then, we extract all connected components, referring to all peptides and proteins that are connected. For a cluster of connected components, we then iterate over all proteins and count the number of peptides that are connected to the particular protein. The protein with the most peptides will then be the razor protein. We remove this protein and the respective peptides and continue with the extraction from the cluster until no more peptides are present.</p>
<p>For efficient implementation, the proteins and peptides are encoded as indexes. To distinguish proteins from peptides, proteins are have a leading 'p'.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_protein_groups" class="doc_header"><code>get_protein_groups</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L403" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_protein_groups</code>(<strong><code>data</code></strong>, <strong><code>pept_dict</code></strong>, <strong><code>fasta_dict</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Function to perform protein grouping by razor approach
ToDo: implement callback for solving
Each protein is indicated with a p -&gt; protein index</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="perform_protein_grouping" class="doc_header"><code>perform_protein_grouping</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L502" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>perform_protein_grouping</code>(<strong><code>data</code></strong>, <strong><code>pept_dict</code></strong>, <strong><code>fasta_dict</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Wrapper function to perform protein grouping by razor approach</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Parallel">Parallel<a class="anchor-link" href="#Parallel"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="score_hdf" class="doc_header"><code>score_hdf</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L532" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>score_hdf</code>(<strong><code>to_process</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>, <strong><code>parallel</code></strong>=<em><code>False</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_ion" class="doc_header"><code>get_ion</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L589" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_ion</code>(<strong><code>i</code></strong>, <strong><code>df</code></strong>, <strong><code>ions</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="protein_groups_hdf" class="doc_header"><code>protein_groups_hdf</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L600" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>protein_groups_hdf</code>(<strong><code>to_process</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="protein_groups_hdf_parallel" class="doc_header"><code>protein_groups_hdf_parallel</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/score.py#L645" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>protein_groups_hdf_parallel</code>(<strong><code>settings</code></strong>, <strong><code>pept_dict</code></strong>, <strong><code>fasta_dict</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Saving">Saving<a class="anchor-link" href="#Saving"> </a></h2>
</div>
</div>
</div>
</div>
 

