---

title: Matching


keywords: fastai
sidebar: home_sidebar

summary: "Functions related to matching"
description: "Functions related to matching"
nb_path: "nbs\09_matching.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs\09_matching.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Dataset-Alignment">Dataset Alignment<a class="anchor-link" href="#Dataset-Alignment"> </a></h2><p>For matching MS2-identifications to MS1-features, we first need to align the datasets on top of each other to be able to transfer identifications correctly. Datasets are aligned by comparing shared precursors and calculating the median offset.
When comparing all files to each other, we get an overdetermined linear equation system. By solving this, we find offset parameters that minimize the shift of all files to each other.
Offset is either applied relative (mz, mobility) or absolute (rt).</p>
<h3 id="Relative-offset">Relative offset<a class="anchor-link" href="#Relative-offset"> </a></h3><p>For some parameters, we would like to have a relative correction of values. Consider the case of different <code>mz</code>-values, e.g. 300 and 600. If we assume that the offset is larger for larger m/z values, we would not want an absolute correction of e.g. +0.5 Da (300.5 and 600.5) but rather a relative correction of e.g. +0.1% (300.3 and 600.6).</p>
<h3 id="Absolute-correction">Absolute correction<a class="anchor-link" href="#Absolute-correction"> </a></h3><p>In contrast to the relative correction, sometimes absolute correction is more applicable. Consider the case of retention time. Here one would rather not expect a relative offset but rather an absolute offset. As an example, consider a lag time of 0.5 Minutes. This would be constant for all retention times and not differ e.g., for later retention times.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calculate_distance" class="doc_header"><code>calculate_distance</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L12" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calculate_distance</code>(<strong><code>table_1</code></strong>:<code>DataFrame</code>, <strong><code>table_2</code></strong>:<code>DataFrame</code>, <strong><code>offset_dict</code></strong>:<code>dict</code>, <strong><code>calib</code></strong>:<code>bool</code>=<em><code>False</code></em>)</p>
</blockquote>
<p>Calculate the distance between two precursors for different columns
Distance can either be relative or absolute.</p>
<p>An example for a minimal offset_dict is: offset_dict = {'mass':'absolute'}</p>
<p>Args:
    table_1 (pd.DataFrame): Dataframe with precusor data.
    table_2 (pd.DataFrame): Dataframe with precusor data.
    offset_dict (dict): Dictionary with column names and how the distance should be calculated.
    calib (bool): Flag to indicate that distances should be calculated on calibrated columns. Defaults to False.</p>
<p>Raises:
    KeyError: If either table_1 or table_2 is not indexed by precursor</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calib_table" class="doc_header"><code>calib_table</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L57" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calib_table</code>(<strong><code>table</code></strong>:<code>DataFrame</code>, <strong><code>delta</code></strong>:<code>Series</code>, <strong><code>offset_dict</code></strong>:<code>dict</code>)</p>
</blockquote>
<p>Apply offset to a table. Different operations for offsets exist.
Offsets will be saved with a '_calib'-suffix. If this does not already exist,
it will be created.</p>
<p>Args:
    table_1 (pd.DataFrame): Dataframe with data.
    delta (pd.Series): Series cotaining the offset.
    offset_dict (dict): Dictionary with column names and how the distance should be calculated.</p>
<p>Raises:
    NotImplementedError: If the type of vonversion is not implemented.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="align" class="doc_header"><code>align</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L90" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>align</code>(<strong><code>deltas</code></strong>:<code>DataFrame</code>, <strong><code>filenames</code></strong>:<code>list</code>, <strong><code>weights</code></strong>:<code>ndarray</code>=<em><code>None</code></em>, <strong><code>n_jobs</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Align multiple datasets.
This function creates a matrix to represent the shifts from each dataset to another.
This effectively is an overdetermined equation system and is solved with a linear regression.</p>
<p>Args:
    deltas (pd.DataFrame): Distances from each dataset to another.
    filenames (list): The filenames of the datasts that were compared.
    weights (np.ndarray, optional): Distances can be weighted by their number of shared elements. Defaults to None.
    n_jobs (optional): Number of processes to be used. Defaults to None (=1).</p>
<p>Returns:
    np.ndarray: alignment values.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calculate_deltas" class="doc_header"><code>calculate_deltas</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L144" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calculate_deltas</code>(<strong><code>combos</code></strong>:<code>list</code>, <strong><code>calib</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>callback</code></strong>:<code>typing.Callable</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>Wrapper function to calculate the distances of multiple files.</p>
<p>In here, we define the offset_dict to make a relative comparison for mz and mobility and absolute for rt.</p>
<p>TODO: This function could be speed-up by parallelization</p>
<p>Args:
    combos (list): A list containing tuples of filenames that should be compared.
    calib (bool): Boolean flag to indicate distance should be calculated on calibrated data.
    callback (Callable): A callback function to track progress.</p>
<p>Returns:
    pd.DataFrame: Dataframe containing the deltas of the files
    np.ndarray: Numpy array containing the weights of each comparison (i.e. number of shared elements)
    dict: Offset dictionary whicch was used for comparing.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="align_files" class="doc_header"><code>align_files</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L233" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>align_files</code>(<strong><code>filenames</code></strong>:<code>list</code>, <strong><code>alignment</code></strong>:<code>DataFrame</code>, <strong><code>offset_dict</code></strong>:<code>dict</code>)</p>
</blockquote>
<p>Wrapper function that aligns a list of files.</p>
<p>Args:
    filenames (list): A list with raw file names.
    alignment (pd.DataFrame): A pandas dataframe containing the alignment information.
    offset_dict (dict): Dictionary with column names and how the distance should be calculated.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="align_datasets" class="doc_header"><code>align_datasets</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L255" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>align_datasets</code>(<strong><code>settings</code></strong>:<code>dict</code>, <strong><code>callback</code></strong>:<code>callable</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>Wrapper function that aligns all experimental files specified a settings file.</p>
<p>Args:
    settings (dict): A list with raw file names.
    callback (Callable): Callback function to indicate progress.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Matching">Matching<a class="anchor-link" href="#Matching"> </a></h2><p>Transfer MS2 identifications to similar MS1 features.</p>
<p>For "match-between-runs" we start with aligning datasets. To create a reference we use for matching, we combine all datasets of a matching group. When using the default settings, the matching group consists of all files. We then group the dataset by precursor and calculate it's average properties (rt, mz, mobility). By combining several files we further are able to calculate a standard deviation. This allows us to know where and with what deviation we would expect an MS1 feature and have the corresponding identification. This is our matching reference. In the matching step, we go through each dataset individually and check if there are precursors in the reference that were not identified in this dataset. We then perform a nearest-neighbor lookup to find if any MS1 features exist that are in close proximity to the reference. The distance metric we use is normed by the median standard of the deviation. Lastly we assess the confidence in a transfered identifcation by using the <code>Mahalanobis</code> distance.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_probability" class="doc_header"><code>get_probability</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L329" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_probability</code>(<strong><code>df</code></strong>:<code>DataFrame</code>, <strong><code>ref</code></strong>:<code>DataFrame</code>, <strong><code>sigma</code></strong>:<code>DataFrame</code>, <strong><code>index</code></strong>:<code>int</code>)</p>
</blockquote>
<p>Probablity estimate of a transfered identification using the Mahalanobis distance.</p>
<p>The function calculates the probability that a feature is a reference feature.
The reference features containing std deviations so that a probability can be estimated.</p>
<p>It is required that the data frames are matched, meaning that the first entry in df matches to the first entry in ref.</p>
<p>Args:
    df (pd.DataFrame): Dataset containing transferered features
    ref (pd.DataFrame): Dataset containing reference features
    sigma (pd.DataFrame): Dataset containing the standard deviations of the reference features
    index (int): Index to the datframes that should be compared</p>
<p>Returns:
    float: Mahalanobis distance</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;mass&#39;</span><span class="p">:[</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">300</span><span class="p">],</span><span class="s1">&#39;rt&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;mass&#39;</span><span class="p">:[</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">302</span><span class="p">],</span><span class="s1">&#39;rt&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>
<span class="n">std</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;mass&#39;</span><span class="p">:[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">],</span><span class="s1">&#39;rt&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First element: (ideal match): </span><span class="si">{</span><span class="n">get_probability</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Second element: (rt slightly off): </span><span class="si">{</span><span class="n">get_probability</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Third element: (mass completely off): </span><span class="si">{</span><span class="n">get_probability</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="convert_decoy" class="doc_header"><code>convert_decoy</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L366" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>convert_decoy</code>(<strong><code>float_</code></strong>)</p>
</blockquote>
<p>Utility function to convert type for decoy after grouping.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="match_datasets" class="doc_header"><code>match_datasets</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/matching.py#L378" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>match_datasets</code>(<strong><code>settings</code></strong>:<code>dict</code>, <strong><code>callback</code></strong>:<code>typing.Callable</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>Match datasets: Wrapper function to match datasets based on a settings file.
This implementation uses matching groups but not fractions.</p>
<p>Args:
    settings (dict): Dictionary containg specifications of the run
    callback (Callable): Callback function to indicate progress.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>
 

