---

title: Recalibration


keywords: fastai
sidebar: home_sidebar

summary: "Functions related to recalibrating"
description: "Functions related to recalibrating"
nb_path: "nbs/07_recalibration.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/07_recalibration.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This notebook contains evertyhing related to recalibration of data.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Recalibration-after-search">Recalibration after search<a class="anchor-link" href="#Recalibration-after-search"> </a></h2><h3 id="Precursor-mass-calibration">Precursor mass calibration<a class="anchor-link" href="#Precursor-mass-calibration"> </a></h3><p>Recalibration refers to the computational step where masses are recalibrated after a first search. The identified peptides are used to calculate the deviations of experimental masses to their theoretical masses. After recalibration, a second search with decreased precursor tolerance is performed.</p>
<p>The recalibration is largely motivated by the software lock mass paper:</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3231580/">Cox J, Michalski A, Mann M. Software lock mass by two-dimensional minimization of peptide mass errors. J Am Soc Mass Spectrom. 2011;22(8):1373-1380. doi:10.1007/s13361-011-0142-8</a></p>
<p>Here, mass offsets are piecewise linearly approximated. The positions for approximation need to fulfill a number of criteria (e.g., a minimum number of samples and a minimum distance). The AlphaPept implementation is slightly modified by employing a more general <code>KNeighborsRegressor</code>-approach. In brief, the calibration is calculated for each point individually by estimating the deviation from its identified neighbors in n-dimensional space (e.g., retention time, mass, mobility).</p>
<p>More specifically, the algorithm consists of the following steps:</p>
<ol>
<li>Outlier removal: We remove outliers from the identified peptides by only accepting identifications with a mass offset that is within n (default 3) standard deviations to the mean.</li>
<li>For each point, we perform a neighbors lookup of the next n (default 100) neighbors. For the neighbor's lookup we need to scale the axis, which is done with a transform function either absolute or relative.</li>
<li>Next, we perform a regression based on the neighbors to determine the mass offset. The contribution of each neighbor is weighted by their distance.</li>
</ol>
<h3 id="Fragment-mass-calibration">Fragment mass calibration<a class="anchor-link" href="#Fragment-mass-calibration"> </a></h3><p>The fragment mass calibration is based on the identified ions (i.e., b-hits and y-hits). For each hit, we calculate the offset to its theoretical mass. The correction is then applied by taking the median offset in ppm and applying it globally.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="remove_outliers" class="doc_header"><code>remove_outliers</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/recalibration.py#L11" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>remove_outliers</code>(<strong><code>df</code></strong>:<code>DataFrame</code>, <strong><code>outlier_std</code></strong>:<code>float</code>)</p>
</blockquote>
<p>Helper function to remove outliers from a dataframe.
Outliers are removed based on the precursor offset mass (o_mass).
All values within x standard deviations to the median are kept.</p>
<p>Args:
    df: Input dataframe that contains a o_mass_ppm-column.
    outlier_std: Range of standard deviations to filter outliers</p>
<p>Returns:
    A dataframe w/o outliers.</p>
<p>Raises:
    ValueError: An error if the column is not present in the dataframe.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="transform" class="doc_header"><code>transform</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/recalibration.py#L45" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>transform</code>(<strong><code>x</code></strong>:<code>ndarray</code>, <strong><code>column</code></strong>:<code>str</code>, <strong><code>scaling_dict</code></strong>:<code>dict</code>)</p>
</blockquote>
<p>Helper function to transform an input array for neighbors lookup used for calibration</p>
<p>Args:
    x: Input array.
    column: String to lookup what scaling should be applied.
    scaling_dict: Lookup dict to retrieve the scaling operation and factor for the column.</p>
<p>Returns:
    A scaled array.</p>
<p>Raises:
    ValueError: An error if the column is not present in the dict.
    NotImplementedError: An error if column exists but it is not implemented how to scale.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="kneighbors_calibration" class="doc_header"><code>kneighbors_calibration</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/recalibration.py#L83" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>kneighbors_calibration</code>(<strong><code>df</code></strong>:<code>DataFrame</code>, <strong><code>features</code></strong>:<code>DataFrame</code>, <strong><code>cols</code></strong>:<code>list</code>, <strong><code>target</code></strong>:<code>str</code>, <strong><code>scaling_dict</code></strong>:<code>dict</code>, <strong><code>calib_n_neighbors</code></strong>:<code>int</code>)</p>
</blockquote>
<p>Calibration using a KNeighborsRegressor.
Input arrays from are transformed to be used with a nearest-neihbor approach.
Based on neighboring points a calibration is calcualted for each input point.</p>
<p>Args:
    df: Input dataframe that contains identified peptides (w/o outliers).
    features: Features dataframe for which the masses are calibrated.
    cols: List of input columns for the calibration.
    scaling_dict: A dictionary that contains how scaling operations are applied.
    calib_n_neighbors: Number of neighbors for calibration.</p>
<p>Returns:
    A numpy array with calibrated masses</p>
<p>Raises:</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_calibration" class="doc_header"><code>get_calibration</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/recalibration.py#L125" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_calibration</code>(<strong><code>df</code></strong>:<code>DataFrame</code>, <strong><code>features</code></strong>:<code>DataFrame</code>, <strong><code>outlier_std</code></strong>:<code>int</code>=<em><code>3</code></em>, <strong><code>calib_n_neighbors</code></strong>:<code>int</code>=<em><code>100</code></em>, <strong><code>calib_mz_range</code></strong>:<code>int</code>=<em><code>20</code></em>, <strong><code>calib_rt_range</code></strong>:<code>float</code>=<em><code>0.5</code></em>, <strong><code>calib_mob_range</code></strong>:<code>float</code>=<em><code>0.3</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Wrapper function to get calibrated values for the precursor mass.</p>
<p>Args:
    df: Input dataframe that contains identified peptides.
    features: Features dataframe for which the masses are calibrated.
    outlier_std: Range in standard deviations for outlier removal.
    calib_n_neighbors: Number of neighbors used for regression.
    calib_mz_range: Scaling factor for mz range.
    calib_rt_range: Scaling factor for rt_range.
    calib_mob_range: Scaling factor for mobility range.
    **kwargs: Arbitrary keyword arguments so that settings can be passes as whole.</p>
<p>Returns:
    corrected_mass: The calibrated mass
    y_hat_std: The standard deviation of the precursor offset after calibration</p>
<p>Raises:</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calibrate_hdf" class="doc_header"><code>calibrate_hdf</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/recalibration.py#L190" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calibrate_hdf</code>(<strong><code>to_process</code></strong>:<code>tuple</code>, <strong><code>callback</code></strong>=<em><code>None</code></em>, <strong><code>parallel</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Wrapper function to get calibrate a hdf file when using the parallel executor.
The function loads the respective dataframes from the hdf, calls the calibration function and applies the offset.</p>
<p>Args:
    to_process: Tuple that contains the file index and the settings dicionary
    callback: Placeholder for callback (unused)
    parallel: Placeholder for parallel usage (unused)</p>
<p>Returns:
    Either True as boolean when calibration is successfull or the Error message as string.</p>
<p>Raises:</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Database-calibration">Database calibration<a class="anchor-link" href="#Database-calibration"> </a></h4><p>Another way to calibrate the fragment and precursor masses is by directly comparing them to a previously generated theoretical mass database. Here, peaks in the distribution of databases are used to align the experimental masses.</p>
<p>The functions <a href="/recalibration.html#get_db_targets"><code>get_db_targets</code></a> and <a href="/recalibration.html#align_run_to_db"><code>align_run_to_db</code></a> are not tested individually but by testing <a href="/recalibration.html#calibrate_fragments"><code>calibrate_fragments</code></a> with acutal data.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_db_targets" class="doc_header"><code>get_db_targets</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/recalibration.py#L304" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_db_targets</code>(<strong><code>db_file_name</code></strong>:<code>str</code>, <strong><code>max_ppm</code></strong>:<code>int</code>=<em><code>100</code></em>, <strong><code>min_distance</code></strong>:<code>float</code>=<em><code>0.5</code></em>, <strong><code>ms_level</code></strong>:<code>int</code>=<em><code>2</code></em>)</p>
</blockquote>
<p>Function to extract database targets for database-calibration.
Based on the FASTA database it finds masses that occur often. These will be used for calibration.</p>
<p>Args:
    db_file_name: Path to the database.
    max_ppm: Maximum distance in ppm between two peaks.
    min_distance: Minimum distance between two calibration peaks.
    ms_level: MS-Level used for calibration, either precursors (1) or fragmasses (2).</p>
<p>Returns:
    numpy array with calibration masses.</p>
<p>Raises:
    ValueError: When ms_level is not valid.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="align_run_to_db" class="doc_header"><code>align_run_to_db</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/recalibration.py#L365" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>align_run_to_db</code>(<strong><code>ms_data_file_name</code></strong>:<code>str</code>, <strong><code>db_array</code></strong>:<code>array</code>, <strong><code>max_ppm_distance</code></strong>:<code>int</code>=<em><code>1000000</code></em>, <strong><code>rt_step_size</code></strong>:<code>float</code>=<em><code>0.1</code></em>, <strong><code>plot_ppms</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>ms_level</code></strong>:<code>int</code>=<em><code>2</code></em>)</p>
</blockquote>
<p>Function align a run to it's database.</p>
<p>Args:
    ms_data_file_name: Path to the run.
    db_array: Numpy array containing the database targets.
    max_ppm_distance: Maximium distance in ppm.
    rt_step_size: Stepsize for rt calibration.
    plot_ppms: boolean Flag to indicate plotting.
    ms_level: ms_level for calibration.</p>
<p>Returns:
    Estimated errors</p>
<p>Raises:
    ValueError: When ms_level is not valid.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calibrate_fragments" class="doc_header"><code>calibrate_fragments</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/recalibration.py#L470" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calibrate_fragments</code>(<strong><code>db_file_name</code></strong>:<code>str</code>, <strong><code>ms_data_file_name</code></strong>:<code>str</code>, <strong><code>ms_level</code></strong>:<code>int</code>=<em><code>2</code></em>, <strong><code>write</code></strong>=<em><code>True</code></em>, <strong><code>plot_ppms</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<p>Wrapper function to calibrate fragments.
Calibrated values are saved to corrected_fragment_mzs</p>
<p>Args:
    db_file_name: Path to database
    ms_data_file_name: Path to ms_data file
    ms_level: MS-level for calibration
    write: Boolean flag for test purposes to avoid writing to testfile.
    plot_ppms: Boolean flag to plot the calibration.</p>
<p>Returns:</p>
<p>Raises:</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>
 

