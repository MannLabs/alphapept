---

title: Input / Output


keywords: fastai
sidebar: home_sidebar

summary: "Functions related to input and output"
description: "Functions related to input and output"
nb_path: "nbs/02_io.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02_io.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/Users/swillems/Documents/software/alphapept/alphapept/chem.py:18: NumbaDeprecationWarning: The &#39;numba.jitclass&#39; decorator has moved to &#39;numba.experimental.jitclass&#39; to better reflect the experimental nature of the functionality. Please update your imports to accommodate this change and see https://numba.pydata.org/numba-doc/latest/reference/deprecation.html#change-of-jitclass-location for the time frame.
  @jitclass(spec)
/Users/swillems/Documents/software/alphapept/alphapept/constants.py:197: NumbaDeprecationWarning: The &#39;numba.jitclass&#39; decorator has moved to &#39;numba.experimental.jitclass&#39; to better reflect the experimental nature of the functionality. Please update your imports to accommodate this change and see https://numba.pydata.org/numba-doc/latest/reference/deprecation.html#change-of-jitclass-location for the time frame.
  @jitclass(spec)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This notebook contains all functions related to importing and exporting files. To access proprietary data formats, we have import functions to access <code>Bruker</code> and <code>Thermo</code> data.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Storing-and-accessing-MS-data">Storing and accessing MS data<a class="anchor-link" href="#Storing-and-accessing-MS-data"> </a></h1><p>As MS hardware has continued to improve over the years, MS data has become more complex. To deal with this complexity, the MS community hase already used many different <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/mas.21522">data formats</a> to store and access. <a href="https://www.hdfgroup.org/solutions/hdf5/">HDF</a> containers are one option, but they have not yet gained widespread support.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="HDF-containers">HDF containers<a class="anchor-link" href="#HDF-containers"> </a></h2><p>In general, an HDF container can be viewed as compressed folder with metadata (i.e. attributes) associated to each single subfolder or file (i.e. data arrays of various types and sizes) within this container. A container might for instance have contents that look like e.g.:</p>

<pre><code>HDF_Container
    {
        meta_data_1: "Some string",
        meta_data_2: 1234567890,
        ...
    }
    array_1
        {
            meta_data_of_array1_1: "Some other string",
            ...
        },
        100x2 int8
    array_2
        1000x2 float64
    subfolder_1
        {
            meta_data_of_subfolder_1_1: "Really any string of any length",
            ...
        }
        array_1_of_subfolder_1
        subfolder_1_1
        ...
    subfolder_n
    ...</code></pre>
<p>A few of the advantages of HDF are e.g.:</p>
<ul>
<li>It has no upper limit with regards to file size</li>
<li>It can be used on disk without consuming RAM memory</li>
<li>It is fully portable on different machines and systems</li>
<li>It is capable of fast IO operations</li>
<li>It allows data to be structured very transparent, while still providing a flexible way to store metadata</li>
<li>...</li>
</ul>
<p>For these reasons, HDF containers have gained popularity in several scientific fields, including (astro)physics and geology. It is therefore no surprise that python has excellent support for HDF containers. The two most used packages are <code>h5py</code> and <code>tables</code>, where the former has generic API and the second is frequently used with <code>pandas</code> dataframes. An excellent viewer for HDF files is <a href="https://support.hdfgroup.org/projects/compass/">HDF Compass</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Using-HDF-containers-for-MS-data">Using HDF containers for MS data<a class="anchor-link" href="#Using-HDF-containers-for-MS-data"> </a></h3><p>We will use <code>h5py</code> to store MS data in HDF containers, inspired by the <a href="https://github.com/swillems/ion_networks">ion_networks</a> repository.</p>
<ul>
<li>First we define a generic class that will serve as an API for HDF containers. To ensure full transparancy, we will include immutable metadata such as <code>creation time</code>, <code>original_file_name</code> and <code>version</code>.</li>
<li>The constructor of an HDF_File will be passed the <code>file_name</code> of an HDF container, an <code>is_read_only</code> flag and <code>is_new_file</code> flag.</li>
<li>To compare HDF_Files, several (magic) functions need to be defined.</li>
<li>Traceabilty and reproducibility are ensured by storing a <code>last_updated</code> and a <code>check</code> function to warn users about potential compatability issues.</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="HDF_File" class="doc_header"><code>class</code> <code>HDF_File</code><a href="" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>HDF_File</code>(<strong><code>file_name</code></strong>:<code>str</code>, <strong><code>is_read_only</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>is_new_file</code></strong>:<code>bool</code>=<em><code>False</code></em>)</p>
</blockquote>
<p>A generic class to store and retrieve on-disk
data with an HDF container.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Contents of HDF containers come in three variants:</p>
<ol>
<li><code>Groups</code>: folders</li>
<li><code>Datasets</code>: arrays</li>
<li><code>Attributes</code>: metadata associated to individual datasets or groups (with the root folder also considered as a normal group)</li>
</ol>
<p>These contents can be accessed with <code>read</code> and <code>write</code> funtions.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="HDF_File.read" class="doc_header"><code>HDF_File.read</code><a href="__main__.py#L7" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>HDF_File.read</code>(<strong><code>group_name</code></strong>:<code>str</code>=<em><code>None</code></em>, <strong><code>dataset_name</code></strong>:<code>str</code>=<em><code>None</code></em>, <strong><code>attr_name</code></strong>:<code>str</code>=<em><code>None</code></em>, <strong><code>return_dataset_shape</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>return_dataset_dtype</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>return_dataset_slice</code></strong>:<code>slice</code>=<em><code>slice(None, None, None)</code></em>)</p>
</blockquote>
<p>Read the contents of an HDF_File. If no <code>group_name</code> has been provided,
read directly from the root group. If no <code>dataset_name</code> has been provided,
read directly from the group. If <code>attr_name</code> is not None,
read the attribute value instead of the contents of a group or dataset.
If <code>attr_name</code> == "", read all attributes as a dict.
The options <code>return_dataset_shape</code>, <code>return_dataset_dtype</code> and
<code>return_dataset_slice</code> allow to minimize IO and RAM usage by reading
datasets only partially.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="HDF_File.write" class="doc_header"><code>HDF_File.write</code><a href="__main__.py#L84" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>HDF_File.write</code>(<strong><code>value</code></strong>, <strong><code>group_name</code></strong>:<code>str</code>=<em><code>None</code></em>, <strong><code>dataset_name</code></strong>:<code>str</code>=<em><code>None</code></em>, <strong><code>attr_name</code></strong>:<code>str</code>=<em><code>None</code></em>, <strong><code>overwrite</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>dataset_compression</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Write a <code>value</code> to an HDF_File. If an 'attr_name' is provided,
<code>value</code> will be stored for this attribute.
If no <code>group_name</code> is provided, write directly to the root group.
If no <code>dataset_name</code> is provided, create a new group with <code>value</code>
as name. If a 'dataset_name' is provided, a 'dataset_compression<code>can be defined to minimize disk usage, at the cost of slower IO.
If the</code>overwrite` flag is True, overwrite the given attribute
or dataset and truncate groups.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Unit tests for this generic HDF class include:</p>
<ul>
<li>Creation and truncation of file with various access.</li>
<li>Writing and reading data from the container.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Conversion-functions">Conversion functions<a class="anchor-link" href="#Conversion-functions"> </a></h2><p><a href="/alphapept/io.html#get_most_abundant"><code>get_most_abundant</code></a>: In order to save spectra in a more memory efficient form, we only keep the n most abundant peaks. This allows us to save data in a fast accessible matrix format.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_most_abundant" class="doc_header"><code>get_most_abundant</code><a href="__main__.py#L12" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_most_abundant</code>(<strong><code>mass</code></strong>, <strong><code>intensity</code></strong>, <strong><code>n_max</code></strong>)</p>
</blockquote>
<p>Returns the n_max most abundant peaks of a spectrum.
Setting <code>n_max</code> to -1 returns all peaks.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Reading-Thermo-Files">Reading Thermo Files<a class="anchor-link" href="#Reading-Thermo-Files"> </a></h2><blockquote><p>The current implementation uses a lot of lists and fills them with list comprehensions. This creates a lot of variables but seems to work reasonably fast. This code could be refactored as all variables end up in a dictionary-type container anyhow.</p>
</blockquote>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="load_thermo_raw" class="doc_header"><code>load_thermo_raw</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L336" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>load_thermo_raw</code>(<strong><code>raw_file</code></strong>, <strong><code>most_abundant</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Load thermo raw file and extract spectra</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="load_thermo_raw_MSFileReader" class="doc_header"><code>load_thermo_raw_MSFileReader</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L431" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>load_thermo_raw_MSFileReader</code>(<strong><code>raw_file</code></strong>, <strong><code>most_abundant</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Load thermo raw file and extract spectra</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Wrapper">Wrapper<a class="anchor-link" href="#Wrapper"> </a></h2><p>We use <code>multiprocessing - pool</code> to be able to convert multiple files to raw in parallel.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="raw_to_npz" class="doc_header"><code>raw_to_npz</code><a href="__main__.py#L3" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>raw_to_npz</code>(<strong><code>to_process</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Wrapper function to convert raw to npz</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="raw_to_npz_parallel" class="doc_header"><code>raw_to_npz_parallel</code><a href="__main__.py#L30" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>raw_to_npz_parallel</code>(<strong><code>path_list</code></strong>, <strong><code>settings</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Bruker">Bruker<a class="anchor-link" href="#Bruker"> </a></h2><p>For accessing Bruker files, we rely on the external <code>timsdata</code> library. 
For <code>ccs</code> values, we need some functions from this library. As the live feature-finder might not be able to determine some charge values, it is intended to perform this calculation at a later stage once we have charge values from the post-processing feature finder.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="load_bruker_raw" class="doc_header"><code>load_bruker_raw</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L578" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>load_bruker_raw</code>(<strong><code>raw_file</code></strong>, <strong><code>most_abundant</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Load bruker raw file and extract spectra</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="one_over_k0_to_CCS" class="doc_header"><code>one_over_k0_to_CCS</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L643" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>one_over_k0_to_CCS</code>(<strong><code>one_over_k0s</code></strong>, <strong><code>charges</code></strong>, <strong><code>mzs</code></strong>)</p>
</blockquote>
<p>convert one_over_k0 to CCS</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="MZML">MZML<a class="anchor-link" href="#MZML"> </a></h2><p>To access mzml files, we rely on the pyteomics package.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="check_sanity" class="doc_header"><code>check_sanity</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L662" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>check_sanity</code>(<strong><code>mass_list</code></strong>)</p>
</blockquote>
<p>Sanity check for mass list to make sure the masses are sorted</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="extract_mzml_info" class="doc_header"><code>extract_mzml_info</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L673" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>extract_mzml_info</code>(<strong><code>input_dict</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="extract_mzxml_info" class="doc_header"><code>extract_mzxml_info</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L690" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>extract_mzxml_info</code>(<strong><code>input_dict</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="read_mzML" class="doc_header"><code>read_mzML</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L703" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>read_mzML</code>(<strong><code>filename</code></strong>, <strong><code>most_abundant</code></strong>)</p>
</blockquote>
<p>Read spectral data from an mzML file and return various lists separately for ms1 and ms2 data.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="read_mzXML" class="doc_header"><code>read_mzXML</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L776" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>read_mzXML</code>(<strong><code>filename</code></strong>, <strong><code>most_abundant</code></strong>)</p>
</blockquote>
<p>Read spectral data from an mzXML file and return various lists separately for ms1 and ms2 data.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Saving">Saving<a class="anchor-link" href="#Saving"> </a></h2><p>For saving, we are currently relying on the NumPy-native npz-container. It offers reasonable speed, dictionary-type access, and does not need individual type definitions.</p>
<p>While we could, in principle, store the mz and int arrays as a list of variable length, this will come at a performance decrease. We, therefore, create an array of the dimensions of the n most abundant peaks and the number of spectra with the function <a href="/alphapept/io.html#list_to_numpy_f32"><code>list_to_numpy_f32</code></a> and fill the unoccupied cells with <code>-1</code>. This allows an increase in accessing times at the cost of additional disk space.</p>
<p>Implementation Note: For large files (e.g., choosing a large number of peaks that should be kept, the npz array can fail and trigger an ZIP64 error. This is supposed to be fixed in a later NumPy version.)</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="list_to_numpy_f32" class="doc_header"><code>list_to_numpy_f32</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L850" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>list_to_numpy_f32</code>(<strong><code>long_list</code></strong>)</p>
</blockquote>
<p>Function to convert a list to float32 array</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="save_query_as_npz" class="doc_header"><code>save_query_as_npz</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L867" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>save_query_as_npz</code>(<strong><code>raw_file_npz</code></strong>, <strong><code>query_data</code></strong>)</p>
</blockquote>
<p>Saves query_data as npz</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="MS_Data-files">MS_Data files<a class="anchor-link" href="#MS_Data-files"> </a></h3><p>Based on the generic HDF_File, a subclass that acts as an MS data container can be implemented. This class should contain all (centroided) fragment ions, all their coordinates, and all the metadata.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="MS_Data_File" class="doc_header"><code>class</code> <code>MS_Data_File</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L888" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>MS_Data_File</code>(<strong><code>file_name</code></strong>:<code>str</code>, <strong><code>is_read_only</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>is_new_file</code></strong>:<code>bool</code>=<em><code>False</code></em>) :: <a href="/alphapept/io.html#HDF_File"><code>HDF_File</code></a></p>
</blockquote>
<p>A generic class to store and retrieve on-disk
data with an HDF container.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A single generic function should allow to read raw data and store spectra. Different arguments allow different vendor formats.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="MS_Data_File.import_raw_DDA_data" class="doc_header"><code>MS_Data_File.import_raw_DDA_data</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L892" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>MS_Data_File.import_raw_DDA_data</code>(<strong><code>file_name</code></strong>:<code>str</code>, <strong><code>most_abundant</code></strong>:<code>int</code>=<em><code>-1</code></em>, <strong><code>callback</code></strong>=<em><code>None</code></em>, <strong><code>query_data</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>vendor</code></strong>:<code>str</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>Import centroided data and store it in the MS_Data_File as
/Raw/{file_name} with the appropriate metadata and relevant
coordinates.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Testing of the MS_Data_File container includes reading and writing from different file formats.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>NOTE: An intermediate MS_Data_File read function is defined to not overload a github PR</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="MS_Data_File.read_DDA_query_data" class="doc_header"><code>MS_Data_File.read_DDA_query_data</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L1023" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>MS_Data_File.read_DDA_query_data</code>()</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>NOTE: An intermediate raw_to_ms_data_file function is defined to not overload github PR.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="raw_to_ms_data_file" class="doc_header"><code>raw_to_ms_data_file</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L1061" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>raw_to_ms_data_file</code>(<strong><code>to_process</code></strong>, <strong><code>callback</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Wrapper function to convert raw to ms_data_file hdf</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Parsing-other-Files">Parsing other Files<a class="anchor-link" href="#Parsing-other-Files"> </a></h2><p>Benchmarking proteomics software against each other is not straightforward as various naming conventions exist, and different algorithms are implemented. In this section, we define some helper functions that allow us to facilitate the comparison of different tools.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Reading-MaxQuant-xml-settings-file">Reading MaxQuant xml settings file<a class="anchor-link" href="#Reading-MaxQuant-xml-settings-file"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="extract_nested" class="doc_header"><code>extract_nested</code><a href="__main__.py#L4" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>extract_nested</code>(<strong><code>child</code></strong>)</p>
</blockquote>
<p>Helper function to extract nested entries</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="extract_mq_settings" class="doc_header"><code>extract_mq_settings</code><a href="__main__.py#L22" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>extract_mq_settings</code>(<strong><code>path</code></strong>)</p>
</blockquote>
<p>Function to return MaxQuant values as a dictionary for a given xml file</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">mq_dict</span> <span class="o">=</span> <span class="n">extract_mq_settings</span><span class="p">(</span><span class="s1">&#39;../testfiles/test_mqpar.xml&#39;</span><span class="p">)</span>
<span class="n">mq_dict</span><span class="p">[</span><span class="s1">&#39;fastaFiles&#39;</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="parse_mq_seq" class="doc_header"><code>parse_mq_seq</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L1120" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>parse_mq_seq</code>(<strong><code>peptide</code></strong>)</p>
</blockquote>
<p>Replaces maxquant convention to alphapept convention
ToDo: include more sequences</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">parse_mq_seq</span><span class="p">(</span><span class="s1">&#39;_AFQPFFVELTM(Oxidation (M))PYSVIR_&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

