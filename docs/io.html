---

title: Input / Output


keywords: fastai
sidebar: home_sidebar



nb_path: "nbs\02_io.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs\02_io.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Reading-raw-input">Reading raw input<a class="anchor-link" href="#Reading-raw-input"> </a></h2><p>Input can be read from three different files formats:</p>
<ul>
<li><code>.raw</code> files describing <code>Thermo</code> raw data.</li>
<li><code>.d</code> folders describing <code>Bruker</code> raw data.</li>
<li><code>.mzML</code> files describing generic input.</li>
</ul>
<p>All reading functions return a <code>query_data</code> dictionary similar to the following structure:</p>

<pre><code>query_data = {
    "scan_list_ms1":   np.array(...)
    "rt_list_ms1":     np.array(...)
    "mass_list_ms1":   np.array(...)
    "int_list_ms1":    np.array(...)
    "ms_list_ms1":     np.array(...)

    "scan_list_ms2":   np.array(...)
    "rt_list_ms2":     np.array(...)
    "mass_list_ms2":   mass_list_ms2
    "int_list_ms2":    int_list_ms2
    "ms_list_ms2":     np.array(...)
    "prec_mass_list2": np.array(...)
    "mono_mzs2":       np.array(...)
    "charge2":         np.array(...)
}</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Thermo">Thermo<a class="anchor-link" href="#Thermo"> </a></h3><p>To read Thermo files, AlphaPept uses the <code>pyrawfilereader</code> package, a Python implementation of the commonly used <code>rawfilereader</code> tool. By using the custom python version, Thermo files can be read without having to install <code>MSFileReader</code>.</p>
<p>The user can pass an additional flag <code>use_profile_ms1</code>. This will then use the profile data which is not centroided already an peform centroiding. Note that this will lead to slightly different intensities, as the centroided data uses the apex and the centroid algorithm the summed intensity.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="load_thermo_raw" class="doc_header"><code>load_thermo_raw</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L9" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>load_thermo_raw</code>(<strong><code>raw_file_name</code></strong>:<code>str</code>, <strong><code>n_most_abundant</code></strong>:<code>int</code>, <strong><code>use_profile_ms1</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>callback</code></strong>:<code>callable</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>Load raw thermo data as a dictionary.</p>
<p>Args:
    raw_file_name (str): The name of a Thermo .raw file.
    n_most_abundant (int): The maximum number of peaks to retain per MS2 spectrum.
    use_profile_ms1 (bool): Use profile data or centroid it beforehand. Defaults to False.
    callback (callable): A function that accepts a float between 0 and 1 as progress. Defaults to None.</p>
<p>Returns:
    tuple: A dictionary with all the raw data and a string with the acquisition_date_time</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Bruker">Bruker<a class="anchor-link" href="#Bruker"> </a></h3><p>To access Bruker files, AlphaPept relies on the external <code>timsdata</code> library from Bruker (available in the <code>alphatims\ext</code> folder, licenses are applicable). Unfortunately, these libraries are only available on Windows and Linux. As a result, the reading of raw data is not available on macOS. However, once raw data is converted to <code>.ms_data.hdf</code> output, other workflow steps (besides feature feating) are possible without problems on macOS.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="load_bruker_raw" class="doc_header"><code>load_bruker_raw</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L141" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>load_bruker_raw</code>(<strong><code>d_folder_name</code></strong>:<code>str</code>, <strong><code>n_most_abundant</code></strong>:<code>int</code>, <strong><code>callback</code></strong>:<code>callable</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Load raw Bruker data as a dictionary.</p>
<p>Args:
    d_folder_name (str): The name of a Bruker .d folder.
    n_most_abundant (int): The maximum number of peaks to retain per MS2 spectrum.
    callback (callable): A function that accepts a float between 0 and 1 as progress. Defaults to None.</p>
<p>Returns:
    tuple: A dictionary with all the raw data and a string with the acquisition_date_time</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For <code>ccs</code> (i.e., ion mobility) values, we need additional functions from the Bruker library. As the live feature-finder might not be able to determine some charge values, it is intended to perform this calculation at a later stage once we have charge values from the post-processing feature finder.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="one_over_k0_to_CCS" class="doc_header"><code>one_over_k0_to_CCS</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L219" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>one_over_k0_to_CCS</code>(<strong><code>one_over_k0s</code></strong>:<code>ndarray</code>, <strong><code>charges</code></strong>:<code>ndarray</code>, <strong><code>mzs</code></strong>:<code>ndarray</code>)</p>
</blockquote>
<p>Retrieve collisional cross section (CCS) values from (mobility, charge, mz) arrays.</p>
<p>Args:
    one_over_k0s (np.ndarray): The ion mobilities (1D-np.float).
    charges (np.ndarray): The charges (1D-np.int).
    mzs (np.ndarray): The mz values (1D-np.float).</p>
<p>Returns:
    np.ndarray: The CCS values.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Due to availbility of Bruker libraries, this can only be tested on Windows and Linux.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Generic-.mzML-files">Generic <code>.mzML</code> files<a class="anchor-link" href="#Generic-.mzML-files"> </a></h3><p>To access <code>.mzML</code> files, we rely on the <code>pyteomics</code> package. For using an mzml format for performing a search, Peak Picking (data centroiding) should be applied to all MS levels of the data.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="check_sanity" class="doc_header"><code>check_sanity</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L248" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>check_sanity</code>(<strong><code>mass_list</code></strong>:<code>ndarray</code>)</p>
</blockquote>
<p>Sanity check for mass list to make sure the masses are sorted.</p>
<p>Args:
    mass_list (np.ndarray): The mz values (1D-np.float).</p>
<p>Raises:
    ValueError: When the mz values are not sorted.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="extract_mzml_info" class="doc_header"><code>extract_mzml_info</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L264" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>extract_mzml_info</code>(<strong><code>input_dict</code></strong>:<code>dict</code>)</p>
</blockquote>
<p>Extract basic MS coordinate arrays from a dictionary.</p>
<p>Args:
    input_dict (dict): A dictionary obtained by iterating over a Pyteomics mzml.read function.</p>
<p>Returns:
    tuple: The rt, masses, intensities, ms_order, prec_mass, mono_mz, charge arrays retrieved from the input_dict.
        If the <code>ms level</code> in the input dict does not equal 2, the charge, mono_mz and prec_mass will be equal to 0.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="load_mzml_data" class="doc_header"><code>load_mzml_data</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L293" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>load_mzml_data</code>(<strong><code>filename</code></strong>:<code>str</code>, <strong><code>n_most_abundant</code></strong>:<code>int</code>, <strong><code>callback</code></strong>:<code>callable</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Load data from an mzml file as a dictionary.</p>
<p>Args:
    filename (str): The name of a .mzml file.
    n_most_abundant (int): The maximum number of peaks to retain per MS2 spectrum.
    callback (callable): A function that accepts a float between 0 and 1 as progress. Defaults to None.</p>
<p>Returns:
    tuple: A dictionary with all the raw data, a string with the acquisition_date_time and a string with the vendor.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Reading-other-files">Reading other files<a class="anchor-link" href="#Reading-other-files"> </a></h2><p>Benchmarking proteomics software against each other is not straightforward as various naming conventions exist and different algorithms are implemented. In this section, we define some helper functions that allow us to read results from other tools and facilitate the comparison of different tools against AlphaPept.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Reading-MaxQuant-.xml-settings-file">Reading MaxQuant .xml settings file<a class="anchor-link" href="#Reading-MaxQuant-.xml-settings-file"> </a></h3><p>One of the most commonly used tools to analyze MS data is MaxQuant. AlphaPept reads MaxQuant .xml files as follows:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="__extract_nested" class="doc_header"><code>__extract_nested</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L421" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>__extract_nested</code>(<strong><code>child</code></strong>)</p>
</blockquote>
<p>Helper function to extract nested entries</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="extract_mq_settings" class="doc_header"><code>extract_mq_settings</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L439" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>extract_mq_settings</code>(<strong><code>path</code></strong>:<code>str</code>)</p>
</blockquote>
<p>Function to return MaxQuant values as a dictionary for a given xml file.</p>
<p>Args:
    path (str): File name of an xml file.</p>
<p>Returns:
    dict: A dictionary with MaxQuant info.</p>
<p>Raises:
    ValueError: When path is not a valid xml file.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">mq_dict</span> <span class="o">=</span> <span class="n">extract_mq_settings</span><span class="p">(</span><span class="s1">&#39;../testfiles/test_mqpar.xml&#39;</span><span class="p">)</span>
<span class="n">mq_dict</span><span class="p">[</span><span class="s1">&#39;fastaFiles&#39;</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;FastaFileInfo&#39;: {&#39;fastaFilePath&#39;: &#39;testfile.fasta&#39;,
  &#39;identifierParseRule&#39;: &#39;&gt;([^\\s]*)&#39;,
  &#39;descriptionParseRule&#39;: &#39;&gt;(.*)&#39;,
  &#39;taxonomyParseRule&#39;: None,
  &#39;variationParseRule&#39;: None,
  &#39;modificationParseRule&#39;: None,
  &#39;taxonomyId&#39;: None}}</pre>
</div>

</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;FastaFileInfo&#39;: {&#39;fastaFilePath&#39;: &#39;testfile.fasta&#39;,
  &#39;identifierParseRule&#39;: &#39;&gt;([^\\s]*)&#39;,
  &#39;descriptionParseRule&#39;: &#39;&gt;(.*)&#39;,
  &#39;taxonomyParseRule&#39;: None,
  &#39;variationParseRule&#39;: None,
  &#39;modificationParseRule&#39;: None,
  &#39;taxonomyId&#39;: None}}</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>AlphaPept incorporates PTMs directly in amino acid sequences with lower case identifiers. Parsing MaxQuant sequences with PTMs is done with:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="parse_mq_seq" class="doc_header"><code>parse_mq_seq</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L467" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>parse_mq_seq</code>(<strong><code>peptide</code></strong>:<code>str</code>)</p>
</blockquote>
<p>Replaces maxquant convention to alphapept convention.</p>
<p>ToDo: include more sequences</p>
<p>Args:
    peptide (str): A peptide sequence from MaxQuant.</p>
<p>Returns:
    str: A parsed peptide sequence compatible with AlphaPept.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A quick test shows the results are correct:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">parse_mq_seq</span><span class="p">(</span><span class="s1">&#39;_AFQPFFVELTM(Oxidation (M))PYSVIR_&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&#39;AFQPFFVELToxMPYSVIR&#39;</pre>
</div>

</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&#39;AFQPFFVELToxMPYSVIR&#39;</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Preprocessing-data">Preprocessing data<a class="anchor-link" href="#Preprocessing-data"> </a></h2><p>Raw data needs to be preprocessed to simplify it for AlphaPept analysis. Currently, this requires:</p>
<ul>
<li>Profiling of the data</li>
<li>Trimming of spectra to retain only the 'n'-most intense peaks</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Centroiding-profile-data">Centroiding profile data<a class="anchor-link" href="#Centroiding-profile-data"> </a></h3><p>Importing raw data frequently results in profile data. When having profile data, Alphapept first needs to perform centroiding to use this data properly. For this, it needs to search local maxima ("peaks") of the intensity as a function of m/z. For this AlphaPept uses the function <a href="/io.html#get_peaks"><code>get_peaks</code></a>. A peak is described by three points, the <code>start</code> of the peak, the <code>center</code>, and the <code>end</code>. The function accepts an intensity array and calculates the delta (gradient) between consecutive data points to determine the start, center, and end.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_peaks" class="doc_header"><code>get_peaks</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L491" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_peaks</code>(<strong><code>int_array</code></strong>:<code>ndarray</code>)</p>
</blockquote>
<p>Detects peaks in an array.</p>
<p>Args:
    int_array (np.ndarray): An array with intensity values.</p>
<p>Returns:
    list: A regular Python list with all peaks.
        A peak is a triplet of the form (start, center, end)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A quick test to illustrate the function:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">int_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">get_peaks</span><span class="p">(</span><span class="n">int_array</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[(2, 6, 9), (9, 13, 16)]</pre>
</div>

</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[(2, 6, 9), (9, 13, 16)]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To determine the center of the peak, we distinguish based on the number of raw data points that are contained in the peak:</p>
<ul>
<li>One data point: m/z value of this point is taken as the center</li>
<li>Two datapoints: Average of the two m/z values, weighted by the intensities</li>
<li>Three or more data points: Gaussian estimation of the center position.</li>
</ul>
<p>For the Gaussian estimation, only the three central points are used to fit a Gaussian Peak shape. The Gaussian is then approximated with the logarithm.</p>
<p>The gaussian estimator is defined in <a href="/io.html#gaussian_estimator"><code>gaussian_estimator</code></a> and is used by the wrapper <a href="/io.html#get_centroid"><code>get_centroid</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_centroid" class="doc_header"><code>get_centroid</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L540" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_centroid</code>(<strong><code>peak</code></strong>:<code>tuple</code>, <strong><code>mz_array</code></strong>:<code>ndarray</code>, <strong><code>int_array</code></strong>:<code>ndarray</code>)</p>
</blockquote>
<p>Wrapper to estimate centroid center positions.</p>
<p>Args:
    peak (tuple): A triplet of the form (start, center, end)
    mz_array (np.ndarray): An array with mz values.
    int_array (np.ndarray): An array with intensity values.</p>
<p>Returns:
    tuple: A tuple of the form (center, intensity)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="gaussian_estimator" class="doc_header"><code>gaussian_estimator</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L573" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>gaussian_estimator</code>(<strong><code>peak</code></strong>:<code>tuple</code>, <strong><code>mz_array</code></strong>:<code>ndarray</code>, <strong><code>int_array</code></strong>:<code>ndarray</code>)</p>
</blockquote>
<p>Three-point gaussian estimator.</p>
<p>Args:
    peak (tuple): A triplet of the form (start, center, end)
    mz_array (np.ndarray): An array with mz values.
    int_array (np.ndarray): An array with intensity values.</p>
<p>Returns:
    float: The gaussian estimate of the center.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The function performs as expected:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">int_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">mz_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">])</span>
<span class="n">peak</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">gaussian_estimator</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">mz_array</span><span class="p">,</span> <span class="n">int_array</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">get_centroid</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">mz_array</span><span class="p">,</span> <span class="n">int_array</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>4.499999999999999
(4.499999999999999, 12)
4.499999999999999
(4.499999999999999, 12)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The detected centroid can also easily be visualized:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="k">def</span> <span class="nf">plot_centroid</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">mz_array</span><span class="p">,</span> <span class="n">int_array</span><span class="p">):</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="n">start</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">peak</span>

    <span class="n">centroid</span> <span class="o">=</span> <span class="n">get_centroid</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span> <span class="n">mz_array</span><span class="p">,</span> <span class="n">int_array</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mz_array</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">int_array</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mz_array</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">int_array</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;b.&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">mz_array</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">mz_array</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Center&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Centroid&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;m/z&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Intensity&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="n">int_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">mz_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">])</span>

<span class="n">peak</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
    
<span class="n">plot_centroid</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">mz_array</span><span class="p">,</span> <span class="n">int_array</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="centroid_data" class="doc_header"><code>centroid_data</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L611" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>centroid_data</code>(<strong><code>mz_array</code></strong>:<code>ndarray</code>, <strong><code>int_array</code></strong>:<code>ndarray</code>)</p>
</blockquote>
<p>Estimate centroids and intensities from profile data.</p>
<p>Args:
    mz_array (np.ndarray): An array with mz values.
    int_array (np.ndarray): An array with intensity values.</p>
<p>Returns:
    tuple: A tuple of the form (mz_array_centroided, int_array_centroided)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Trimming-spectra-to-retain-the-n-most-intense-peaks">Trimming spectra to retain the <code>n</code> most intense peaks<a class="anchor-link" href="#Trimming-spectra-to-retain-the-n-most-intense-peaks"> </a></h3><p><a href="/io.html#get_most_abundant"><code>get_most_abundant</code></a>: In order to save spectra in a more memory-efficient form, we only keep the n most abundant peaks. This allows us to save data in a fast, accessible matrix format.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_most_abundant" class="doc_header"><code>get_most_abundant</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L650" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_most_abundant</code>(<strong><code>mass</code></strong>:<code>ndarray</code>, <strong><code>intensity</code></strong>:<code>ndarray</code>, <strong><code>n_max</code></strong>:<code>int</code>)</p>
</blockquote>
<p>Returns the n_max most abundant peaks of a spectrum.</p>
<p>Args:
    mass (np.ndarray): An array with mz values.
    intensity (np.ndarray): An array with intensity values.
    n_max (int): The maximum number of peaks to retain.
        Setting <code>n_max</code> to -1 returns all peaks.</p>
<p>Returns:
    tuple: the filtered mass and intensity arrays.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For saving, we are currently relying on the hdf-container (see below).</p>
<p>While we could, in principle, store the mz and int arrays as a list of variable length, this will come at a performance decrease. We, therefore, create an array of the dimensions of the n most abundant peaks and the number of spectra with the function <a href="/io.html#list_to_numpy_f32"><code>list_to_numpy_f32</code></a> and fill the unoccupied cells with <code>-1</code>. This allows an increase in accessing times at the cost of additional disk space.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="list_to_numpy_f32" class="doc_header"><code>list_to_numpy_f32</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L678" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>list_to_numpy_f32</code>(<strong><code>long_list</code></strong>:<code>list</code>)</p>
</blockquote>
<p>Function to convert a list to np.float32 array.</p>
<p>Args:
    long_list (list): A regular Python list with values that can be converted to floats.</p>
<p>Returns:
    np.ndarray: A np.float32 array.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Saving-output">Saving output<a class="anchor-link" href="#Saving-output"> </a></h2><p>As MS hardware has continued to improve over the years, MS data has become more complex. To deal with this complexity, the MS community has already used many different <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/mas.21522">data formats</a> to store and access data. <a href="https://www.hdfgroup.org/solutions/hdf5/">HDF</a> containers are one option, but they have not yet gained widespread support.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="HDF-containers-in-general">HDF containers in general<a class="anchor-link" href="#HDF-containers-in-general"> </a></h3><p>In general, an HDF container can be viewed as a compressed folder with metadata (i.e., attributes) associated to each single subfolder or file (i.e., data arrays of various types and sizes) within this container. A container might, for instance have contents that look like, e.g.:</p>

<pre><code>HDF_Container
    {
        meta_data_1: "Some string",
        meta_data_2: 1234567890,
        ...
    }
    array_1
        {
            meta_data_of_array1_1: "Some other string",
            ...
        },
        100x2 int8
    array_2
        1000x2 float64
    subfolder_1
        {
            meta_data_of_subfolder_1_1: "Really any string of any length",
            ...
        }
        array_1_of_subfolder_1
        subfolder_1_1
        ...
    subfolder_n
    ...</code></pre>
<p>A few of the advantages of HDF are, e.g.:</p>
<ul>
<li>It has no upper limit with regards to file size</li>
<li>It can be used on disk without consuming RAM memory</li>
<li>It is fully portable on different machines and systems</li>
<li>It is capable of fast IO operations</li>
<li>It allows data to be structured very transparent while still providing a flexible way to store metadata</li>
<li>...</li>
</ul>
<p>For these reasons, HDF containers have gained popularity in several scientific fields, including (astro)physics and geology. It is, therefore, no surprise that Python has excellent support for HDF containers. The two most used packages are <code>h5py</code> and <code>tables</code>, where the former has a generic API and the second is frequently used with <code>pandas</code> dataframes. An excellent viewer for HDF files is <a href="https://support.hdfgroup.org/projects/compass/">HDF Compass</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Using-HDF-containers-in-AlphaPept">Using HDF containers in AlphaPept<a class="anchor-link" href="#Using-HDF-containers-in-AlphaPept"> </a></h3><p>AlphaPept uses the python <code>h5py</code> package to store MS data in HDF containers, inspired by the <a href="https://github.com/swillems/ion_networks">ion_networks</a> repository.</p>
<ul>
<li>First, a generic class is defined that will serve as an API for HDF containers. To ensure full transparency, this will include immutable metadata such as <code>creation time</code>, <code>original_file_name</code> and <code>version</code>.</li>
<li>The constructor of an HDF_File will be passed the <code>file_name</code> of an HDF container, an <code>is_read_only</code> flag, an <code>is_overwritable</code> flag and <code>is_new_file</code> flag.</li>
<li>To compare HDF_Files, several (magic) functions need to be defined.</li>
<li>Traceability and reproducibility are ensured by storing a <code>last_updated</code> and a <code>check</code> function to warn users about potential compatibility issues.</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="HDF_File" class="doc_header"><code>class</code> <code>HDF_File</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L710" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>HDF_File</code>(<strong><code>file_name</code></strong>:<code>str</code>, <strong><code>is_read_only</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>is_new_file</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>is_overwritable</code></strong>:<code>bool</code>=<em><code>False</code></em>)</p>
</blockquote>
<p>A generic class to store and retrieve on-disk
data with an HDF container.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Contents of HDF containers come in three variants:</p>
<ol>
<li><code>Groups</code>: folders</li>
<li><code>Datasets</code>: arrays</li>
<li><code>Attributes</code>: metadata associated with individual datasets or groups (with the root folder also considered as a normal group)</li>
</ol>
<p>These contents can be accessed with <code>read</code> and <code>write</code> functions.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="HDF_File.read" class="doc_header"><code>HDF_File.read</code><a href="__main__.py#L55" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>HDF_File.read</code>()</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="HDF_File.write" class="doc_header"><code>HDF_File.write</code><a href="__main__.py#L58" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>HDF_File.write</code>()</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Unit tests for this generic HDF class include:</p>
<ul>
<li>Creation and truncation of files with various access.</li>
<li>Writing and reading data from the container.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="The-final-.ms_data.hdf-file">The final <code>.ms_data.hdf</code> file<a class="anchor-link" href="#The-final-.ms_data.hdf-file"> </a></h3><p>Based on the generic HDF_File, a subclass that acts as an MS data container can be implemented. This class should contain all (centroided) fragment ions, all their coordinates, and all the metadata.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="MS_Data_File" class="doc_header"><code>class</code> <code>MS_Data_File</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L1124" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>MS_Data_File</code>(<strong><code>file_name</code></strong>:<code>str</code>, <strong><code>is_read_only</code></strong>:<code>bool</code>=<em><code>True</code></em>, <strong><code>is_new_file</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>is_overwritable</code></strong>:<code>bool</code>=<em><code>False</code></em>) :: <a href="/io.html#HDF_File"><code>HDF_File</code></a></p>
</blockquote>
<p>A class to store and retrieve on-disk MS data with an HDF container.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A single generic function should allow to read raw data and store spectra. Different arguments allow different vendor formats.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="MS_Data_File.import_raw_DDA_data" class="doc_header"><code>MS_Data_File.import_raw_DDA_data</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L1130" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>MS_Data_File.import_raw_DDA_data</code>(<strong><code>file_name</code></strong>:<code>str</code>, <strong><code>n_most_abundant</code></strong>:<code>int</code>=<em><code>-1</code></em>, <strong><code>callback</code></strong>:<code>callable</code>=<em><code>None</code></em>, <strong><code>query_data</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>vendor</code></strong>:<code>str</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>Load centroided data and save it to this object.</p>
<p>Args:
    file_name (str): The file name with raw data (Thermo, Bruker or mzml).
    n_most_abundant (int): The maximum number of peaks to retain per MS2 spectrum.            Defaults to -1.
    callback (callable): A function that accepts a float between 0 and 1 as progress. Defaults to None.
    query_data (dict):
        A dictionary with raw data.
        If this is not None, data will only be saved and not imported.
        Defaults to None.
    vendor (str): The vendor name, must be Thermo or Bruker if provided.
        Defaults to None.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="index_ragged_list" class="doc_header"><code>index_ragged_list</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L1164" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>index_ragged_list</code>(<strong><code>ragged_list</code></strong>:<code>list</code>)</p>
</blockquote>
<p>Create lookup indices for a list of arrays for concatenation.</p>
<p>Args:
    value (list): Input list of arrays.</p>
<p>Returns:
    indices: A numpy array with indices.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Testing of the MS_Data_File container includes reading and writing from different file formats.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>While that HDF data structure could be used directly, it is often easier to read it and return a <code>query_data</code> dictionary similar to those that are returned by the readers of <code>Thermo</code>, <code>Bruker</code>, <code>mzML</code> and <code>mzXML</code> raw data.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="MS_Data_File.read_DDA_query_data" class="doc_header"><code>MS_Data_File.read_DDA_query_data</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L1322" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>MS_Data_File.read_DDA_query_data</code>(<strong><code>calibrated_fragments</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>force_recalibrate</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>swmr</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Read query data from this ms_data object and return it as a query_dict.</p>
<p>Args:
    calibrated_fragments (bool): If True, calibrated fragments are retrieved.
        Calibration offsets can already be present in the ms_data or recalculated.
        Defaults to False.
    force_recalibrate (bool): If calibrated fragments is True,
        recalibrate mzs values even if a recalibration is already provided.
        Defaults to False.
    swmr (bool): Open the file in swmr mode. Defaults to False.
    **kwargs (type): Can contain a database file name that was used for recalibration.</p>
<p>Returns:
    dict: A query_dict with data for MS1 and MS2 scans.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Usage-in-workflows">Usage in workflows<a class="anchor-link" href="#Usage-in-workflows"> </a></h2><p>To use all the above functionality from a workflow with several parameters, the following functions are defined. These functions also allow parallel processing.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="raw_conversion" class="doc_header"><code>raw_conversion</code><a href="https://github.com/mannlabs/alphapept/tree/master/alphapept/io.py#L1400" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>raw_conversion</code>(<strong><code>to_process</code></strong>:<code>dict</code>, <strong><code>callback</code></strong>:<code>callable</code>=<em><code>None</code></em>, <strong><code>parallel</code></strong>:<code>bool</code>=<em><code>False</code></em>)</p>
</blockquote>
<p>Wrapper function to convert raw to ms_data_file hdf.</p>
<p>Args:
    to_process (dict): A dictionary with settings indicating which files are to be processed and how.
    callback (callable): A function that accepts a float between 0 and 1 as progress. Defaults to None.
    parallel (bool): If True, process multiple files in parallel.
        This is not implemented yet!
        Defaults to False.</p>
<p>Returns:
    bool: True if and only if the conversion was succesful.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The following commands are bookkeeping to make sure this and other notebooks are properly parsed to python modules.</p>

</div>
</div>
</div>
</div>
 

